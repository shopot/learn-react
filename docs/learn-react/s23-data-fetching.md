---
sidebar_position: 23
---

# Получение данных в React

В предыдущем материале мы работали с "псевдоданными", которые возвращались из промиса, созданного вручную. 
Теперь мы готовы перейти к реальному взаимодействию с внешними API. 

Мы будем использовать репозиторий https://github.com/shopot/mock-server-api, он позволит быстро запустить свой собственный сервер API.

Следуйте инструкции раздела **Установка и запуск** в файле README.md репозитория, что бы запустить сервер.

## Замена моковых данных на реальные

Ранее мы работали с локальными данными, которые возвращались из промиса. Теперь заменим это на реальные запросы к API.

Удалим моковые данные и функции, которые их возвращали, и настроим запросы к нашему новому API:

```tsx
// src/App.tsx
// ... остальной код компонента
const API_ENDPOINT = 'http://localhost:3000/catalog';

function App() {
  // ... остальной код компонента

  useEffect(() => {
    setIsLoading(true);

    fetch(API_ENDPOINT)
      .then((response) => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }

        return response.json();
      })
      .then((data) => {
        setStories(data);
        setIsLoading(false);
      })
      .catch(() => {
        setIsLoading(false);
        setIsError(true);
      });
  }, []);
  
  // ... остальной код компонента
 }
```

Поскольку мы использовали ту же структуру данных `Story`, то нам не пришлось ничего менять.
Истории и по-прежнему можно фильтровать после их получения с помощью функции поиска и удалять при помощи обработчика `handleRemoveStory`.

Конечно же это не типичное поведение, так как поиск должен производится с помощью отправки нового запроса на сервер, как и любая из CRUD операций.

## Как это работает

### Инициализация компонента

При первом рендере (начальный рендер) компонента происходит следующее:

1. Выполняется инициализация состояний:
   - `searchTerm` - создаётся через кастомный хук `usePersistedSearch` (начальное значение - пустая строка).
   - `stories` - массив историй, изначально пустой.
   - `isLoading` - флаг загрузки (`false`). 
   - `isError` - флаг ошибки (`false`).
2. Выполняется начальный рендер компонента:
   - React вычисляет JSX с начальными значениями состояний
   - Показывается заголовок, поле ввода и пустой список (так как `isLoading=false` и `stories=[]`).

### Работа эффекта (useEffect)

После начального рендера срабатывает `useEffect` (так как массив зависимостей пустой):

```tsx
useEffect(() => {
  setIsLoading(true); // 1. Устанавливаем флаг загрузки

  fetch(API_ENDPOINT) // 2. Отправляем запрос
    .then((response) => {
      if (!response.ok) throw new Error(); // 3. Проверяем ответ
      return response.json(); // 4. Парсим JSON
    })
    .then((result) => {
      setStories(result); // 5. Успех - сохраняем данные
      setIsLoading(false); // 6. Снимаем флаг загрузки
    })
    .catch(() => {
      setIsLoading(false); // 7. Ошибка - снимаем флаг загрузки
      setIsError(true); // 8. Устанавливаем флаг ошибки
    });
}, []); // Зависимости - эффект сработает только при монтировании после начального рендера
```

### Обновление состояний и повторные рендеры

После выполнения эффекта происходят следующие обновления:

1. Успешный запрос:
    - `setStories(result)` → обновляет `stories`.
    - `setIsLoading(false)` → меняет `isLoading` на `false`.
    - React планирует повторный рендер.
2. Ошибка запроса:
    - `setIsLoading(false)` и `setIsError(true)`.
    - React планирует повторный рендер.
3. Выполняется повторный рендер компонента.

### Ключевые моменты работы React

1. Порядок выполнения:
    - Рендер → Эффекты → Ожидание промисов → Обновление состояния → Повторный рендер
2. Оптимизации:
    - `filteredStories` вычисляется при каждом рендере.
    - Эффект с пустыми зависимостями выполняется только один раз.

3. Поток данных:
    - Данные текут сверху вниз (props).
    - События идут снизу вверх (callbacks).

## Заключение

Поздравляю! В этом уроке вы совершили важный шаг в изучении React - перешли от работы с моковыми данными к взаимодействию с реальным API. Давайте закрепим ключевые моменты:

1. Реальные данные вместо моков - вы научились делать настоящие HTTP-запросы с помощью fetch API, что является фундаментальным навыком для frontend-разработчика.
2. Жизненный цикл данных - освоили полный цикл работы с асинхронными данными:
    - Установка состояния загрузки.
    - Отправка запроса.
    - Обработка успешного ответа.
    - Обработка ошибок.
    - Обновление интерфейса.
3. Работа с эффектами - поняли, как `useEffect` позволяет выполнять side-эффекты (например, HTTP-запросы) в нужный момент жизненного цикла компонента.
4. Управление состоянием - научились координировать несколько состояний (загрузка, ошибки, данные) для создания отзывчивого интерфейса.

Важно отметить, что текущая реализация с клиентской фильтрацией - это только первый шаг. В реальных проектах:

    - Фильтрация обычно выполняется на сервере.
    - Используются более сложные системы управления состоянием.
    - Добавляется оптимизация запросов.