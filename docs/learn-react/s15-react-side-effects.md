---
sidebar_position: 15
---

# Side effects и хук useEffect

В React-приложениях компоненты должны быть предсказуемыми: при одинаковых входных данных (props и state) они должны возвращать одинаковый результат. Однако в реальных приложениях часто требуется выполнять действия, выходящие за рамки чистого рендеринга — например, запросы к API, работу с localStorage, подписку на события или таймеры. Такие операции называются побочными эффектами (side effects).

Побочные эффекты усложняют логику компонентов, поскольку их выполнение может влиять на внешнее окружение или зависеть от него. React предоставляет специальный инструмент для управления ими — хук `useEffect`, который позволяет контролировать, когда и как эти эффекты

## Использование`useEffect` для сохранения состояния поиска

Давайте посмотрим, как добавить функциональность для сохранения последнего поискового запроса в компоненте Search с помощью React-хуков. Это позволит приложению запоминать введённый пользователем поисковый термин даже после перезагрузки страницы.
Сохранение поискового запроса в localStorage

Сначала мы будем использовать локальное хранилище браузера (localStorage), чтобы сохранять значение `searchTerm` при каждом изменении. Затем при инициализации компонента мы проверим, есть ли сохранённое значение, и используем его в качестве начального состояния.

Полный листинг `App`:

```tsx
import { useState } from 'react';
import { stories } from './stores/stories';
import { List } from './components/List';
import { Search } from './components/Search';

function App() {
  const [searchTerm, setSearchTerm] = useState(
    localStorage.getItem('search') ?? '',
  );

  const handleSearch = (value: string) => {
    setSearchTerm(value);
    localStorage.setItem('search', value);
  };

  const filteredStories = stories.filter(({ title }) => {
    return title.toLowerCase().includes(searchTerm.toLowerCase().trim());
  });

  return (
    <div>
      <h1>Frontend JavaScript frameworks</h1>
      <Search search={searchTerm} onSearch={handleSearch} />
      <hr />
      <List items={filteredStories} />
    </div>
  );
}

export default App;
```

Теперь, если пользователь введёт новый поисковый запрос и обновит страницу, браузер восстановит последнее значение из localStorage.

## Проблема: смешивание логики состояния и побочных эффектов

Однако текущая реализация имеет недостаток: функция `handleSearch` не только обновляет состояние, но и выполняет побочный эффект (запись в localStorage). 
Если где-то в приложении `searchTerm` будет обновляться другим способом (например, через кнопку сброса или из другого дочернего компонента), localStorage не синхронизируется автоматически.

## Решение: использование useEffect для побочных эффектов

Чтобы сделать код более надёжным, мы вынесем побочный эффект в хук `useEffect`. Это гарантирует, что localStorage всегда будет актуальным, независимо от того, как и где обновляется `searchTerm`.

```tsx
import { useEffect, useState } from 'react';
import { stories } from './stores/stories';
import { List } from './components/List';
import { Search } from './components/Search';

function App() {
    const [searchTerm, setSearchTerm] = useState(
        localStorage.getItem('search') ?? '',
    );

    useEffect(() => {
        localStorage.setItem('search', searchTerm);
    }, [searchTerm]);

    // ...
}

export default App;
```

**Как работает `useEffect`?**

- Первый аргумент — функция, содержащая побочный эффект (в нашем случае — сохранение в localStorage).
- Второй аргумент — массив зависимостей. Если любая из зависимостей изменяется, эффект выполняется заново.

В нашем примере useEffect срабатывает:

- При первом рендере компонента.
- При каждом изменении `searchTerm`.

## Варианты использования `useEffect`

- **Без зависимостей ([])**

    Эффект выполняется только один раз после первого рендера (аналог componentDidMount).
    Пример: загрузка данных при монтировании.

- **С массивом зависимостей ([dep1, dep2])**

    Эффект выполняется при первом рендере и при изменении любой зависимости.
    Пример: обновление данных при изменении userId.

- **Без массива зависимостей**

    Эффект выполняется после каждого рендера (и при первом рендере).
    Может привести к бесконечным циклам, если менять состояние внутри эффекта, которое является зависимостью.

**Использование функции очистки (cleanup)**

- Предотвращает утечки памяти (например, отменяет подписки, если компонент удалён).
- Останавливает фоновые процессы (таймеры, запросы), которые больше не нужны.
- Обеспечивает корректную работу асинхронных операций при быстрых изменениях зависимостей

Пример использования `useEffect` с очисткой `setInterval`:

```tsx
import { useState, useEffect } from 'react';

export const Timer = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // Создаем интервал, который увеличивает счетчик каждую секунду
    const intervalId = setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);

    // Функция очистки - будет вызвана при:
    // 1. Размонтировании компонента
    // 2. Перед следующим выполнением эффекта (если зависимости изменились)
    return () => {
      clearInterval(intervalId);
    };
  }, []); // Пустой массив зависимостей = эффект только при монтировании

  return (
    <div>
      <p>Таймер: {count} секунд</p>
    </div>
  );
};
```

Без очистки интервала при размонтировании компонента таймер продолжал бы работать в фоне, что могло бы привести к утечкам памяти и ошибкам.

## Заключение

Использование `useEffect` для побочных эффектов делает код чище и надёжнее. Теперь:

- Логика обновления состояния (`setSearchTerm`) отделена от побочных эффектов.
- localStorage всегда синхронизирован с актуальным значением searchTerm.
- Приложение стало более предсказуемым и удобным для пользователя.

Этот подход можно применять не только для работы с localStorage, но и для других побочных эффектов, таких как вызовы API, подписки на события и т. д.