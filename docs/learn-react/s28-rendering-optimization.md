---
sidebar_position: 28
---

# Использование `useCallback` и `React.memo`

В предыдущих разделах мы изучили обычные обработчики событий и колбэк-функции. 
Теперь познакомимся с концепцией мемоизированных обработчиков в сочетании механизмом кэширования пропсов, которые помогают оптимизировать производительность React-приложений, исключая повторные рендеры компонента.

## Проблема повторных рендеров

Рассмотрим сценарий со счетчиком:

```tsx
// ... остальной код
function App() {
  const [searchTerm, setSearchTerm] = usePersistedSearch('search', '');
  const { data, isError, isLoading } = useGetStoriesQuery(searchTerm);
  const [counter, setCounter] = useState(0);

  const handleSubmit = (value: string) => {
    setSearchTerm(value);
  };

  return (
    <div>
      {counter}{' '}
      <button onClick={() => setCounter((prev) => prev + 1)}>Click</button>
      <h1>Showcasing innovation every day</h1>
      {/* ... остальной код */}
    </div>
  );
}    
```

Мы добавили новое состояние в компонент `App` и кнопку с обработчиком для кго изменения.
Теперь при каждом нажатии на кнопку происходит ререндер компонента `App` и всех его дочерних компонентов.

Что бы убедиться, что наш дочерний компонент `SearchForm` ререндерится при ререндере родительского компонента, добавим логировние в компонент:

```tsx
  // ... остальной код
  console.count('SearchForm');

  const isSubmitDisabled = loading || !inputValue;
  // ... остальной код
```

Теперь в консоле можно увидеть:

```text
SearchForm: 1
SearchForm: 2
SearchForm: 3
SearchForm: 4
SearchForm: 5
SearchForm: 6
...
```

## Использование `React.memo`

`memo` — это функция высшего порядка (Higher-Order Component), которая используется для оптимизации производительности компонентов в React. 
Она предотвращает повторный рендеринг функциональных компонентов, **если их пропсы не изменились**.

Когда вы оборачиваете компонент в `memo`, React сравнивает текущие пропсы с предыдущими при каждом рендере.

Давайте обернем компонент `SearchForm` и посмотрим на результат: 

```tsx
import React, { memo, useState } from 'react';
import { InputField } from './InputField';

type SearchFormProps = {
  loading: boolean;
  defaultValue: string;
  onSubmit: (searchValue: string) => void;
};

export const SearchForm = memo(
  ({ loading, defaultValue, onSubmit }: SearchFormProps) => {
    const [inputValue, setInputValue] = useState(defaultValue);

    // ... остальной код
  },
);
```

При нажатии на кнопку счетчика, компонент SearchForm по-прежнему ререндерится.

Когда компонент React обновляется, все функции внутри него создаются заново, 
то есть при каждом рендере компонента `App` создаётся новая функция `handleSubmit` и передается в компонент `SearchForm`, 
где `memo` обнаруживает изменение пропса и запускает повторный рендер компонента `SearchForm`.  

## Кэширование определения функций между повторными рендерами

`useCallback` — это React Hook, который позволяет кэшировать определение функции между повторными рендерами.

```tsx
// Вызываем useCallback и передаем в него определение нашего обработчика
const handleSubmit = useCallback((value: string) => {
  setSearchTerm(value);
}, []);
```

**Как это работает?**

- Внутри `useCallback` мы определяем функцию, которая принимает строку `value` и вызывает `setSearchTerm` с этим значением.
- `useCallback` "запоминает" эту функцию между рендерами компонента.
- При каждом новом рендере React будет возвращать ту же самую функцию (по ссылке), а не создавать новую.
- Пустой массив зависимостей [] указывает, что функция не зависит ни от каких значений из внешней области видимости. Функция будет создана один раз при монтировании компонента и больше никогда не изменится.

## Когда использовать `useCallback`:

- Когда функция передаётся в оптимизированные дочерние компоненты (React.memo)
- Когда функция используется в зависимостях других хуков (`useEffect`, `useMemo` и т.д.)
- Для стабильных обработчиков, которые не зависят от изменяющихся значений компонента
- Когда используются ресурсоёмкие вычисления в функциях.


## Практические рекомендации

- Используйте `useCallback` и `memo` вместе для максимального эффекта: `memo` кэширует компонент, `useCallback` — его колбэки.
- Не злоупотребляйте оптимизацией — применяйте эти инструменты только для компонентов, где действительно заметны проблемы с производительностью.
- Помните о зависимостях — правильно указывайте зависимости `useCallback`, чтобы функция обновлялась, когда это действительно необходимо.


## Заключение

В этой статье мы узнали что дочерние компоненты по умолчанию рендерятся вместе с родителем.
Для того что бы изменить это поведение, необходимо использовать  `React.memo` в связке с `useCallback`.

`React.memo` предотвращает лишние рендеры, сравнивая пропсы компонента, но бесполезна при передаче новых ссылок на функции при каждом рендере.

`useCallback` решает проблему "плавающих ссылок", сохраняя идентичную ссылку на функцию между рендерами, когда её зависимости не меняются.
