---
sidebar_position: 12
---

# Контролируемые компоненты в React

## Что такое контролируемые компоненты?

Контролируемые компоненты — это HTML-элементы формы (например, `<input>`), значения которых полностью управляются React через пропсы.
В отличие от нативных HTML-элементов, которые хранят своё состояние внутри DOM, контролируемые компоненты делегируют управление состоянием React.

## Проблема неконтролируемых компонентов

Рассмотрим пример из предыдущей статьи, внесём небольшие изменения:

```tsx
// Инициализация состояния пустой строкой
const [searchTerm, setSearchTerm] = useState('React');
```
Хотя начальное состояние `searchTerm` установлено в 'React', input-поле не отражает это значение, потому что:

- Поле ввода хранит своё состояние в DOM.
- React не контролирует это внутреннее состояние.
- Фильтрация списка работает, но визуальное представление рассинхронизировано.

Чтобы сделать компонент контролируемым, необходимо передать значение в атрибут `value` через пропсы компонента: 

1. Передаем значение через пропсы

```tsx
<Search search={searchTerm} onSearch={setSearchTerm} />
```

2. Связываем значение с `input` в компоненте `Search`

```tsx
type SearchProps = { 
  search: string;
  onSearch: (value: string) => void;
};

export const Search = ({ search, onSearch }: SearchProps) => {
  return (
    <div>
      <label htmlFor="search">Search: </label>
      <input
        id="search"
        type="text"
        value={search} // Значение и пропсов
        onChange={(e) => onSearch(e.target.value)} // Обработчик изменения поля ввода
      />
    </div>
  );
};
```

Теперь поле ввода начинается с правильного начального значения, используя значение из состояния React.
Кроме того, когда мы меняем поисковый запрос, мы заставляем поле ввода использовать значение из состояния React

Здесь мы плавно подошли с вам к тому, что контролируемые компоненты реализуют один из важных принципов React: **Однонаправленный поток данных**.

## Однонаправленный поток данных (Unidirectional Data Flow)

Однонаправленный поток данных — это архитектурный принцип React, при котором данные передаются **только в одном направлении**: от родительских компонентов к дочерним через пропсы.
Обновление состояния происходит через callback-функции (Callback Handlers), которые поднимают изменения наверх.


```text
┌─────────────┐    Данные    ┌─────────────┐
│  Родитель   │─────────────>│   Ребёнок   │
│  (Parent)   │<─────────────│   (Child)   │
└─────────────┘   Callback   └─────────────┘
```

React-приложение и его компоненты начинают работу с начального состояния, которое может передаваться вниз по иерархии через пропсы. 
При первом рендере формируется пользовательский интерфейс (UI). Когда происходит побочное действие (Side Effect) — например, пользовательский ввод или загрузка данных с API — изменения фиксируются в состоянии React. 
После обновления состояния все затронутые компоненты, зависящие от этого состояния или связанных props, перерисовываются (функция компонента выполняется заново).

## Как работает обновление интерфейса

1. **Инициализация компонентов** - сначала React создаёт экземпляры всех компонентов сверху вниз по иерархии, включая хуки (например, useState) с их начальными значениями.
2. **Ожидание взаимодействий** - после первого рендера интерфейс ожидает побочных действий (клики пользователя, ответы API и т.д.).
3. **Обновление состояния** - при изменении состояния (через функцию обновления из `useState`) React:
    - Запоминает новое значение.
    - Определяет, какие компоненты зависят от изменившихся данных. 
    - Запускает повторный рендер компонентов и необходимых частей и интерфейса.

Таким образом при изменении состояния через `useState` React помечает компоненты для обновления, 
вычисляет минимальные изменения и эффективно обновляет только необходимые части интерфейса, сохраняя при этом текущие значения состояния между рендерами.

## Важный нюанс работы хука useState

Хук `useState` инициализируется только один раз при первом рендере компонента.
При последующих вызовах функции компонента React использует текущие значения из внутреннего хранилища, а не начальные значения.
Это может показаться неочевидным, но именно так достигается согласованность состояния между рендерами.

Пример с `Counter`:

```tsx
const Counter = () => {
  const [count, setCount] = useState(0); // 0 - только при первом рендере

  // При последующих рендерах берётся актуальное значение count
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}
```

## Заключение

Контролируемые компоненты — фундаментальная концепция React, которая:

- Обеспечивает полный контроль над данными форм.
- Поддерживает согласованность между состоянием и UI.
- Позволяет легко интегрировать валидацию и другие преобразования.
- Соответствует философии однонаправленного потока данных.

