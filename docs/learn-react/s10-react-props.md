---
sidebar_position: 10
---

# Компоненты и пропсы

В текущем приложении у нас есть переменная `people`, которая объявлена в глобальной области видимости в компоненте `List`.
Такой подход может сработать при одном единственном случае, но он не масштабируется, мы не можем использовать компонент `List` с другой переменной или переменной из другого файла.

## Передача данных через пропсы

Чтобы избежать проблем, связанных с привязкой данных через глобальные переменные, в React принято передавать данные между компонентами с помощью пропсов (props). Это позволяет сделать данные локальными для каждого компонента и организовать чёткий поток данных сверху вниз.

## Перемещаем данные в отдельный файл

Первым шагом мы убираем переменную `people` из глобальной области видимости из компонента List.
Кроме того, переименуем её в более подходящее название — например `peopleData`.

Для этого определим новый файл `src/peopleData.ts`

```ts
export const peopleData = [
    {
        id: 1,
        name: 'Creola Katherine Johnson',
        profession: 'mathematician',
    },
    {
        id: 2,
        name: 'Mario José Molina-Pasquel Henríquez',
        profession: 'chemist',
    },
    {
        id: 3,
        name: 'Mohammad Abdus Salam',
        profession: 'physicist',
    },
    {
        id: 4,
        name: 'Percy Lavon Julian',
        profession: 'chemist',
    },
    {
        id: 5,
        name: 'Subrahmanyan Chandrasekhar',
        profession: 'astrophysicist',
    },
];
```

## Передача массива через пропсы в компонент `List`

Теперь, чтобы компонент `List` получил данные, мы передаём их как пропс с именем `items`, в данном случае наш компонент `List`.
Обычно, когда речь идет о переиспользуемых компонентах, названия пропсов, как правило, не связаны по смыслу с контекстом передаваемых данных. 

```tsx
import type React from 'react';
import { List } from './components/List';
import { peopleData } from './peopleData';

const App = () => {
    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        console.log('Input changed:', event.target.value);
    };

    return (
        <div>
            <h1>The People's list</h1>
            <label htmlFor="search">Search: </label>
            <input id="search" type="text" onChange={handleChange} />
            <hr />
            <List items={peopleData} />
        </div>
    );
};

export default App;
```

Здесь:

- В компоненте `App` импортируется переменная `peopleData`. 
- При передаче в `List` мы передаём её через атрибут `items`. 
- Внутри `List` мы можем получить доступ к этому массиву через объект `props`.

## Использование пропсов в компоненте `List`

В самом компоненте `List` мы принимаем пропсы в качестве аргумента функции и читаем из них `items`:

```tsx
type ListItem = {
    id: number;
    name: string;
    profession: string;
};

type ListProps = {
    items: ListItem[];
};

export const List = (props: ListProps) => {
  const { items } = props;
    
  return (
    <ul>
      {items.map(({ id, name, profession }) => (
        <li key={id}>
          {name} {profession}
        </li>
      ))}
    </ul>
  );
};
```

В данном случае наиболее предпочтительнее использовать деструктуризацию пропсов в месте их объявления:

```tsx
...
export const List = ({ items }: ListProps) => (
  <ul>
    {items.map(({ id, name, profession }) => (
      <li key={id}>
        {name} {profession}
      </li>
    ))}
  </ul>
);

```

Преимущества использования пропсов:

- Избегаем загрязнения глобальной области видимости.
- Переменная peopleData теперь определена в модуле в отдельном файле и не влияет на другие части приложения.
- Данные передаются явно через пропсы, что улучшает читаемость и поддержку кода.
- Компонент становится переиспользуемым, так как получает данные извне через пропсы.

## О типизации пропсов

На текущий момент существует несколько подходов типизации пропсов, мы рассмотрим наиболее часто встречающихся из них.

1. **Использование типа (`type`) для описания пропсов**

```tsx
type ListProps = {
  items: ListItem[];
};
```

Вместо `type` можно использовать `interface`, принципиальной разницы нет, выбор скорее будет продиктован стайлгайдом на конкретном проекте.

2. **Inline-аннотация пропсов**

```tsx
export const List = ({ items }: { items:  ListItem[]}) => {
  ...
};
```

Минусы этого подхода:

- Меньшая читаемость, особенно при использовании большого количества пропсов.
- Меньше возможностей повторного использования и расширения.

3. **Использование `React.FC` (`React.FunctionComponent`)**

```tsx
export const List: React.FC<{items: ListItem[]}> = ({ items }) => {
  ...
};
```

Данный подход обеспечивает типизацию props, а также добавляет children по умолчанию.
В последние версии React и TypeScript (после 5.1) использование `React.FC`считается больше стилистическим вопросом и иногда избегается.

На сегодняшний день в сообществе TypeScript и React существует тенденция избегать `React.FC` по нескольким причинам:

- Он автоматически добавляет `children`, что не всегда необходимо.
- Может скрывать ошибки в типах пропсов.
- Указывает возвращаемый тип `ReactNode`, который является объединением нескольких типов, что не везде является верным, так как зачастую требуется только `React.JSX.Element`

**Рекомендуемый подход:**

- Используйте `interface` (или `type`) для описания пропсов (первый из примеров).
- Передавайте пропсы через деструктуризацию в компонент, с явно указанным типом.
- В случае необходимости более строгой типизации возвращаемого компонента — указывайте тип возвращаемого значения (`React.JSX.Element`).


## Заключение

Использование пропсов — это базовый и эффективный способ передачи данных между компонентами React. Вместо того чтобы брать данные из глобальной области, мы делаем их локальными для компонентов и передаём вниз по иерархии через пропсы. Такой подход делает код более масштабируемым, понятным и управляемым.
