---
sidebar_position: 10
---

# Компоненты и пропсы

В текущем приложении у нас есть переменная `stories`, которая объявлена в глобальной области видимости в компоненте `List`.
Такой подход может сработать при одном единственном случае, но он не масштабируется, мы не можем использовать компонент `List` с другой переменной или переменной из другого файла.

## Передача данных через пропсы

Чтобы избежать проблем, связанных с привязкой данных через глобальные переменные, в React принято передавать данные между компонентами с помощью пропсов (props). Это позволяет сделать данные локальными для каждого компонента и организовать чёткий поток данных сверху вниз.

## Перемещаем данные в отдельный файл

Первым шагом мы убираем переменную `stories` из глобальной области видимости из компонента List.

Для этого определим новый файл `src/stores/stories.ts`

```ts
export const stories = [
  {
    id: 1,
    title: 'React',
    description:
      'Библиотека для создания пользовательских интерфейсов, основанная на компонентной архитектуре.',
  },
  {
    id: 2,
    title: 'Vue.js',
    description:
      'Прогрессивный фреймворк для построения интерфейсов, легкий и гибкий в использовании.',
  },
  {
    id: 3,
    title: 'Angular',
    description:
      'Мощный фреймворк от Google для разработки одностраничных приложений с богатым функционалом.',
  },
  {
    id: 4,
    title: 'Svelte',
    description:
      'Современный фреймворк, который компилирует компоненты в чистый JavaScript, обеспечивая высокую производительность.',
  },
  {
    id: 5,
    title: 'Ember.js',
    description:
      'Фреймворк для амбициозных веб-приложений с встроенным роутингом и инструментами разработки.',
  },
];
```

## Передача массива через пропсы в компонент `List`

Теперь, чтобы компонент `List` получил данные, мы передаём их как пропс с именем `items`, в данном случае наш компонент `List`.
Обычно, когда речь идет о переиспользуемых компонентах, названия пропсов, как правило, не связаны по смыслу с контекстом передаваемых данных и имеют более обобщенные названия. 

```tsx
import { List } from './components/List';
import { stories } from './stores/stories';

function App() {
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    console.log('Input changed:', event.target.value);
  };

  return (
    <div>
      <h1>Frontend JavaScript frameworks</h1>
      <label htmlFor="search">Search: </label>
      <input id="search" type="text" onChange={handleChange} />
      <hr />
      <List items={stories} />
    </div>
  );
}

export default App;
```

Здесь:

- В компоненте `App` импортируется переменная `peopleData`. 
- При передаче в `List` мы передаём её через атрибут `items`. 
- Внутри `List` мы можем получить доступ к этому массиву через объект `props`.

## Использование пропсов в компоненте `List`

В самом компоненте `List` мы принимаем пропсы в качестве аргумента функции и читаем из них `items`:

```tsx
type ListProps = {
  items: Array<{
    id: number;
    title: string;
    description: string;
  }>;
};

export const List = (props: ListProps) => {
  const { items } = props;
    
  return (
    <ul>
      {items.map(({ id, title, description }) => (
        <li key={id}>
          <span>{title}</span>
          <span>{description}</span>
        </li>
      ))}
    </ul>
  );
};
```

В данном случае наиболее предпочтительнее использовать деструктуризацию пропсов в месте их объявления:

```tsx
export const List = ({ items }: ListProps) => (
  <ul>
    {items.map(({ id, title, description }) => (
      <li key={id}>
        <span>{title}</span>
        <span>{description}</span>
      </li>
    ))}
  </ul>
);
```

Преимущества использования пропсов:

- Избегаем загрязнения глобальной области видимости.
- Переменная `stories` теперь определена в модуле в отдельном файле и не влияет на другие части приложения.
- Данные передаются явно через пропсы, что улучшает читаемость и поддержку кода.
- Компонент становится переиспользуемым, так как получает данные извне через пропсы.

## О типизации пропсов

На текущий момент существует несколько подходов типизации пропсов, мы рассмотрим наиболее часто встречающихся из них.

1. **Использование типа (`type`) для описания пропсов**

```ts
type ListProps = {
  items: Array<{
    id: number;
    title: string;
    description: string;
  }>;
};
```

Вместо `type` можно использовать `interface`, принципиальной разницы нет, выбор скорее будет продиктован стайлгайдом на конкретном проекте.

2. **Inline-аннотация пропсов**

```tsx
export const List = ({ items }: {
  items: Array<{
    id: number;
    title: string;
    description: string;
  }>}) => {
  ...
};
```

Минусы этого подхода:

- Меньшая читаемость, особенно при использовании большого количества пропсов.
- Меньше возможностей повторного использования и расширения.

3. **Использование `React.FC` (`React.FunctionComponent`)**

```tsx
export const List: React.FC<ListProps> = ({ items }) => {
  ...
};
```

Данный подход обеспечивает типизацию props, а также добавляет children по умолчанию.
В последние версии React и TypeScript (после 5.1) использование `React.FC`считается больше стилистическим вопросом и иногда избегается.

На сегодняшний день в сообществе TypeScript и React существует тенденция избегать `React.FC` по нескольким причинам:

- Он автоматически добавляет `children`, что не всегда необходимо.
- Может скрывать ошибки в типах пропсов.
- Указывает возвращаемый тип `ReactNode`, который является объединением нескольких типов, что не везде является верным, так как зачастую требуется только `React.JSX.Element`

**Рекомендуемый подход:**

- Используйте `interface` (или `type`) для описания пропсов (первый из примеров).
- Передавайте пропсы через деструктуризацию в компонент, с явно указанным типом.
- В случае необходимости более строгой типизации возвращаемого компонента — указывайте тип возвращаемого значения (`React.JSX.Element`).


## Заключение

Использование пропсов — это базовый и эффективный способ передачи данных между компонентами React. Вместо того чтобы брать данные из глобальной области, мы делаем их локальными для компонентов и передаём вниз по иерархии через пропсы. Такой подход делает код более масштабируемым, понятным и управляемым.
