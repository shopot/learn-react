---
sidebar_position: 24
---

# Повторный запрос данных в React

## От клиентской к серверной фильтрации

В предыдущем разделе мы загружали список данных один раз, а затем фильтровали их на стороне клиента. 
Теперь мы изменим этот подход и будем выполнять поиск на стороне сервера, используя динамический поисковый запрос `searchTerm`.

### Шаг 1: Упрощаем логику компонента `App`:

Сначала удалим фильтрацию на клиенте (`filteredStories`), так как теперь мы будем получать уже отфильтрованные данные с сервера. 
Передаем в компонент `List` просто массив историй:

```tsx
function App() {
  // ... остальной код

  return (
    <div>
      {/* ... другие элементы */}
      <hr />
      {isError && <p>Что-то пошло не так...</p>}

      {isLoading ? (
        <p>Загрузка...</p>
      ) : (
        <List items={stories} onRemoveItem={handleRemoveStory} />
      )}
    </div>
  );
}
```

### Шаг 2: Динамический поисковый запрос

Вместо жестко заданного поискового запроса будем использовать текущее значение `searchTerm` из состояния компонента. 
Мы будем осуществлять поиск по полю `title`, JSON-Server поддерживает запрос вида ` GET /catalog?title_like=server` (Add _like to filter (RegExp supported)):

```tsx
function App() {
  // ... остальной код

  useEffect(() => {
    setIsLoading(true);

    fetch(`${API_ENDPOINT}?title_like=${searchTerm}`)
      .then((response) => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }

        return response.json();
      })
      .then((result) => {
        setStories(result);
        setIsLoading(false);
      })
      .catch(() => {
        setIsLoading(false);
        setIsError(true);
      });
  }, []);

  // ... остальной код
}
```

### Шаг 3: Добавляем зависимость от searchTerm

Чтобы запрос выполнялся при каждом изменении поискового запроса, добавляем `searchTerm` в массив зависимостей хука `useEffect`:

```tsx
function App() {
  // ... остальной код

  useEffect(() => {
    setIsLoading(true);

    fetch(`${API_ENDPOINT}?title_like=${searchTerm}`)
      .then((response) => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }

        return response.json();
      })
      .then((result) => {
        setStories(result);
        setIsLoading(false);
      })
      .catch(() => {
        setIsLoading(false);
        setIsError(true);
      });
  }, [searchTerm]);

  // ... остальной код
}
```

Что мы изменили?

- Перенесли фильтрацию на сервер - теперь поиск выполняется не в браузере, а на сервере, что более правильно с архитектурной точки зрения.
- Динамические запросы - вместо одного начального запроса мы теперь можем делать запросы с разными параметрами поиска.
- Автоматический повторный запрос - благодаря зависимости от searchTerm, React будет автоматически выполнять новый запрос при его изменении.

## Проблемы текущей реализации

Хотя наш код теперь работает "правильнее", есть одна проблема - запрос выполняется при каждом изменении `input`, даже если пользователь еще не закончил ввод. Это:

- Создает избыточную нагрузку на сервер.
- Может привести к ошибкам при частых запросах.
- Может вызывать "гонку запросов" (когда более ранний запрос возвращается позже более позднего).

В следующей статье мы рассмотрим как решать такие проблемы с помощью:

- Дебаунсинга (задержки запроса)
- Отмены предыдущих запросов

## Заключение

В этом материале мы освоили важный этап разработки React-приложений — переход от клиентской к серверной фильтрации данных. 

Давайте подведем итоги и перечислим ключевые моменты:

- **Серверный поиск вместо клиентского** - мы заменили локальную фильтрацию (`filteredStories`) на полноценные запросы к API с параметром `title_like`, что соответствует лучшим практикам работы с данными.
- **Динамические запросы** - реализовали систему, где изменение searchTerm автоматически инициирует новый запрос к серверу благодаря зависимости в useEffect.
- **Оптимизированная архитектура** - упростили компонент `App`, удалив лишнюю логику фильтрации и оставив только отображение полученных с сервера данных.