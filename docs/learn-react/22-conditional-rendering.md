---
sidebar_position: 22
---

# Условный рендеринг в React

Условный рендеринг в React работает так же, как условные выражения работают в JavaScript. 
Бывает нужно объяснить React, как состояние влияет на то, какие компоненты требуется скрыть, а какие — отрендерить, и как именно.

В этой статье мы рассмотрим различные подходы к условному рендерингу, особенно при работе с асинхронными данными.

## Основы условного рендеринга

При работе с асинхронными данными в React мы часто сталкиваемся с несколькими состояниями:

1. Данные загружаются.
2. Данные успешно загружены. 
3. Произошла ошибка при загрузке.

Рассмотрим, как обрабатывать эти состояния:

```tsx
function App() {
  const [searchTerm, setSearchTerm] = usePersistedSearch('search', '');
  const [stories, setStories] = useState<Story[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isError, setIsError] = useState(false);

  useEffect(() => {
    setIsLoading(true);

    getAsyncStories()
      .then((result) => {
        setStories(result.data.stories);
        setIsLoading(false);
      })
      .catch(() => {
        setIsError(true);
        setIsLoading(false);
      });
  }, []);
  
  // ... остальной код
 }
```

## Тернарный оператор для условного рендеринга

Когда у нас есть два возможных состояния (например, загрузка и отображение данных), удобно использовать тернарный оператор:

```tsx
{isLoading ? (
  <p>Загрузка...</p>
) : (
  <List items={filteredStories} onRemoveItem={handleRemoveStory} />
)}
```

## Логический оператор `&&` для условного рендеринга

Если нужно отобразить компонент только при выполнении условия (или ничего не отображать), можно использовать оператор `&&`:

```tsx
{isError && <p>Что-то пошло не так...</p>}
```

В JavaScript выражение `true && 'Hello World'` всегда равно `Hello World`, а `false && 'Hello World'` всегда равно `false`. React использует это поведение: если условие истинно, отображается выражение после `&&`, если ложно — React пропускает рендеринг.

## Комбинирование состояний

В реальных приложениях часто нужно обрабатывать несколько состояний одновременно:

```tsx
{isError && <p>Что-то пошло не так...</p>}

{isLoading ? (
  <p>Загрузка...</p>
) : (
  <List items={filteredStories} onRemoveItem={handleRemoveStory} />
)}
```

## Как это работает?

**Полная последовательность выполнения (успешный сценарий):**

1. Монтирование компонента →
2. Инициализация состояний →
3. Первый рендер →
4. Запуск `useEffect` →
5. `setIsLoading(true)` →
6. Ре-рендер с `isLoading=true` →
7. Выполнение `getAsyncStories()` →
8. Разрешение промиса →
9. `setStories(data)` →
10. `setIsLoading(false)` →
11. Финальный ре-рендер

**Особенности порядка выполнения:**

- Все `setState` внутри эффекта выполняются после завершения первоначального рендера.
- Каждый `setState` вызывает новый ре-рендер.
- Обновления состояния объединяются, если они находятся в одном такте событий.
- `useEffect` с пустым массивом зависимостей (`[]`) выполняется только один раз - после монтирования.


## Практические рекомендации

- **Начальное состояние:** Используйте пустой массив `[]` вместо `null` для начального состояния списков, чтобы избежать дополнительных проверок в JSX.
- **Придерживайтесь следующего порядка при рендеринге:**
  - Сначала проверяем ошибки (`isError`).
  - Затем состояние загрузки (`isLoading`.)
  - И только потом рендерим данные.
- **Особенности оператора `&&`:**
  - Работает как "рендери то, что справа если выражение слева равно `true`".
  - Не требует `else`-ветки как тернарный оператор.
  - Возвращает `null` если условие ложно (React это игнорирует).
  - Выражение слева всегда должно иметь результат `Boolean`. 
- **Компонент `ErrorBoundary`:** Для более сложных приложений рассмотрите использование `ErrorBoundary` для перехвата ошибок в компонентах.

     
## Заключение

Условный рендеринг — мощный инструмент в React, который делает интерфейсы более динамичными и отзывчивыми. Освоение различных подходов к условному рендерингу поможет вам создавать более надежные и удобные приложения, особенно при работе с асинхронными данными.